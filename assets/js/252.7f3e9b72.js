(window.webpackJsonp=window.webpackJsonp||[]).push([[252],{264:function(e,t,i){"use strict";i.r(t);var s=i(0),o=Object(s.a)({},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"ts-一些技巧"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ts-一些技巧","aria-hidden":"true"}},[e._v("#")]),e._v(" TS 一些技巧")]),e._v(" "),i("p",[e._v("原文："),i("a",{attrs:{href:"https://www.ably.io/blog/typescript-is-making-programming-better",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.ably.io/blog/typescript-is-making-programming-better"),i("OutboundLink")],1)]),e._v(" "),i("h2",{attrs:{id:"what’s-improved-for-us"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#what’s-improved-for-us","aria-hidden":"true"}},[e._v("#")]),e._v(" What’s improved for us")]),e._v(" "),i("p",[e._v("After migrating to TypeScript it’s not only easier to catch any errors caused mainly due to bad typing it also makes maintenance, especially further refactoring of code, extremely easy. Since TypeScript includes enough information about types within the code itself you can completely do away with JSdocs. New engineers joining the team therefore find it easier to quickly onboard themselves just by reading through the code.")]),e._v(" "),i("h2",{attrs:{id:"tips-tricks-what-no-one-told-you-about-typescript"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tips-tricks-what-no-one-told-you-about-typescript","aria-hidden":"true"}},[e._v("#")]),e._v(" Tips & Tricks: What no one told you about TypeScript")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("noImplicitAny: Failing to annotate function parameters and class methods will lead TypeScript to implicitly consider the type as any. This defeats the very purpose of using TypeScript for type checking as these places are mostly prone to type errors. To avoid this, you can set the noImplicityAny flag in the tsconfig file which forces you to annotate these, even if that means you explicitly specify any as a type.")])]),e._v(" "),i("li",[i("p",[e._v("Object vs Any: If you don’t know which parameters a type will have, prefer the object type or { [key: string]: any } to any.")])]),e._v(" "),i("li",[i("p",[e._v("Wherever possible, use object type instead of any, since it is more restrictive in terms of the existence of certain constructs.")])]),e._v(" "),i("li",[i("p",[e._v("Function Overloads: Use function overloads where multiple call signatures are expected. This improves safety, readability and type inference and provides better editor suggestions.")])]),e._v(" "),i("li",[i("p",[e._v("Function and class return types: Consider not always adding return types to short functions if it’s obvious. These can generally be inferred by the compiler implicitly, while adding them would add an unnecessary visual noise.")])]),e._v(" "),i("li",[i("p",[e._v("Const variables rarely require type declarations: For some variables such as const MAX_NUM: number = 1000 skipping the type would cause no harm in terms of understanding the variable type as it is pretty obvious, so it would make more sense to declutter the code by skipping this info.")])]),e._v(" "),i("li",[i("p",[e._v("Make use of interfaces where possible vs. classes: Interfaces allow duck typing so they give you much more flexibility in terms of how you would like to pass on function arguments while still ensuring correct types. This is not possible with classes.")])])])])},[],!1,null,null,null);t.default=o.exports}}]);